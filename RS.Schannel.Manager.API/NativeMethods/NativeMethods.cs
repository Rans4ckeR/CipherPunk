// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable
#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436
namespace Windows.Win32;

using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using Windows.Win32.Foundation;
using Windows.Win32.Security.Cryptography;

internal static partial class PInvoke
{
    internal static readonly global::System.Guid REGISTRY_EXTENSION_GUID = new Guid(0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2);

    [DllImport("NCrypt", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows6.0.6000")]
    public static extern unsafe HRESULT SslFreeBuffer(void* pvInput);

    [DllImport("NCrypt", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows6.0.6000")]
    public static extern unsafe HRESULT SslOpenProvider(NCRYPT_PROV_HANDLE* phSslProvider, PCWSTR pszProviderName, NCRYPT_FLAGS dwFlags);

    [DllImport("NCrypt", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows6.0.6000")]
    public static extern unsafe HRESULT SslEnumCipherSuites(NCRYPT_PROV_HANDLE hProvider, [Optional] NCRYPT_KEY_HANDLE hPrivateKey, NCRYPT_SSL_CIPHER_SUITE** ppCipherSuite, void** ppEnumState, NCRYPT_FLAGS dwFlags);

    [DllImport("NCrypt", ExactSpelling = true)]
    [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
    [SupportedOSPlatform("windows6.0.6000")]
    public static extern unsafe HRESULT SslEnumProtocolProviders(uint* pdwProviderCount, NCryptProviderName** ppProviderList, NCRYPT_FLAGS dwFlags = 0U);

    public static unsafe HRESULT SslEnumProtocolProviders(out uint pdwProviderCount, out NCryptProviderName* ppProviderList, NCRYPT_FLAGS dwFlags = 0U)
    {
        fixed (NCryptProviderName** ppProviderListLocal = &ppProviderList)
        {
            fixed (uint* pdwProviderCountLocal = &pdwProviderCount)
            {
                HRESULT __result = PInvoke.SslEnumProtocolProviders(pdwProviderCountLocal, ppProviderListLocal, dwFlags);
                return __result;
            }
        }
    }

    public static unsafe HRESULT SslOpenProvider(out NCryptFreeObjectSafeHandle phSslProvider, string pszProviderName, NCRYPT_FLAGS dwFlags = 0U)
    {
        fixed (char* pszProviderNameLocal = pszProviderName)
        {
            NCRYPT_PROV_HANDLE phSslProviderLocal;
            HRESULT __result = PInvoke.SslOpenProvider(&phSslProviderLocal, pszProviderNameLocal, dwFlags);
            phSslProvider = new NCryptFreeObjectSafeHandle(phSslProviderLocal, ownsHandle: true);
            return __result;
        }
    }

    public static unsafe HRESULT SslEnumCipherSuites(SafeHandle hSslProvider, SafeHandle? hPrivateKey, out NCRYPT_SSL_CIPHER_SUITE* ppCipherSuite, ref void* ppEnumState, NCRYPT_FLAGS dwFlags = 0U)
    {
        bool hSslProviderAddRef = false;
        bool hPrivateKeyAddRef = false;

        try
        {
            fixed (NCRYPT_SSL_CIPHER_SUITE** ppCipherSuiteLocal = &ppCipherSuite)
            {
                fixed (void** ppEnumStateLocal = &ppEnumState)
                {
                    NCRYPT_PROV_HANDLE hSslProviderLocal;

                    if (hSslProvider is object)
                    {
                        hSslProvider.DangerousAddRef(ref hSslProviderAddRef);
                        hSslProviderLocal = (NCRYPT_PROV_HANDLE)hSslProvider.DangerousGetHandle();
                    }
                    else
                        hSslProviderLocal = default;

                    NCRYPT_KEY_HANDLE hPrivateKeyLocal;

                    if (hPrivateKey is object)
                    {
                        hPrivateKey.DangerousAddRef(ref hPrivateKeyAddRef);
                        hPrivateKeyLocal = (NCRYPT_KEY_HANDLE)hPrivateKey.DangerousGetHandle();
                    }
                    else
                        hPrivateKeyLocal = default;

                    HRESULT __result = PInvoke.SslEnumCipherSuites(hSslProviderLocal, hPrivateKeyLocal, ppCipherSuiteLocal, ppEnumStateLocal, dwFlags);
                    return __result;
                }
            }
        }
        finally
        {
            if (hSslProviderAddRef)
                hSslProvider.DangerousRelease();

            if (hPrivateKeyAddRef)
                hPrivateKey.DangerousRelease();
        }
    }
}