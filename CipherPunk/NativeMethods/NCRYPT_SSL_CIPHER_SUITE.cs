// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using global::System.Runtime.Versioning;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32;

internal struct NCRYPT_SSL_CIPHER_SUITE
{
    internal SslProviderProtocolId dwProtocol;

    internal SslProviderCipherSuiteId dwCipherSuite;

    internal SslProviderCipherSuiteId dwBaseCipherSuite;

    internal __char_64 szCipherSuite;

    internal __char_64 szCipher;

    internal uint dwCipherLen;

    internal uint dwCipherBlockLen;

    internal __char_64 szHash;

    internal uint dwHashLen;

    internal __char_64 szExchange;

    internal uint dwMinExchangeLen;

    internal uint dwMaxExchangeLen;

    internal __char_64 szCertificate;

    internal SslProviderKeyTypeId dwKeyType;

    //internal __char_64 szCipherMode;

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal struct __char_64
    {
        private const int SpanLength = 64;

        /// <summary>The length of the inline array.</summary>
        internal readonly int Length => SpanLength;
        internal unsafe fixed char Value[SpanLength];

        /// <summary>
        /// Gets a ref to an individual element of the inline array.
        /// ⚠ Important ⚠: When this struct is on the stack, do not let the returned reference outlive the stack frame that defines it.
        /// </summary>
        [UnscopedRef]
        internal unsafe ref char this[int index] => ref Value[index];

        /// <summary>
        /// Gets this inline array as a span.
        /// </summary>
        /// <remarks>
        /// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
        /// </remarks>
        [UnscopedRef]
        internal unsafe Span<char> AsSpan() => MemoryMarshal.CreateSpan(ref Value[0], SpanLength);

        /// <summary>
        /// Gets this inline array as a span.
        /// </summary>
        /// <remarks>
        /// ⚠ Important ⚠: When this struct is on the stack, do not let the returned span outlive the stack frame that defines it.
        /// </remarks>
        [UnscopedRef]
        internal unsafe readonly ReadOnlySpan<char> AsReadOnlySpan() => MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef(Value[0]), SpanLength);

        internal readonly bool Equals(ReadOnlySpan<char> value) => value.Length == SpanLength ? AsReadOnlySpan().SequenceEqual(value) : AsReadOnlySpan().SliceAtNull().SequenceEqual(value);

        internal readonly bool Equals(string value) => Equals(value.AsSpan());

        /// <summary>
        /// Copies the fixed array to a new string up to the specified length regardless of whether there are null terminating characters.
        /// </summary>
        /// <exception cref="ArgumentOutOfRangeException">
        /// Thrown when <paramref name="length"/> is less than <c>0</c> or greater than <see cref="Length"/>.
        /// </exception>
        internal readonly string ToString(int length) => AsReadOnlySpan().Slice(0, length).ToString();

        /// <summary>
        /// Copies the fixed array to a new string, stopping before the first null terminator character or at the end of the fixed array (whichever is shorter).
        /// </summary>
        public override readonly string ToString() => AsReadOnlySpan().SliceAtNull().ToString();
        public static implicit operator __char_64(string value) => value.AsSpan();
        public static implicit operator __char_64(ReadOnlySpan<char> value)
        {
            Unsafe.SkipInit(out __char_64 result);
            value.CopyTo(result.AsSpan());
            int initLength = value.Length;
            result.AsSpan().Slice(initLength, SpanLength - initLength).Clear();
            return result;
        }
    }
}